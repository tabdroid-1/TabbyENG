#pragma once

#include <Tabby/Asset/AssetBase.h>
#include <AL/al.h>
#include <AL/alc.h>
#include <sndfile.h>

namespace Tabby {

typedef enum AudioSampleType {
    Int16,
    Float,
    IMA4,
    MSADPCM
} AudioSampleType;

class Audio;

class AudioEngine {
public:
    static void Init();
    static void Shutdown();

    static float GetVolume();
    static void SetVolume(float newVolume);

    static void PlaySfx(const std::string& sfxFileName);
    static void PauseSfxMixer();
    static void UnpauseSfxMixer();
    static void StopSfxMixer();

    static void SetPlayerMusic(Shared<Audio> audio, std::size_t index = 0);
    static void UnsetPlayerMusic(std::size_t index = 0);

    static void PlayMusicPlayer(std::size_t index = 0);
    static void PauseMusicPlayer(std::size_t index = 0);
    static bool IsMusicPlaying(std::size_t index = 0);

    static float GetMusicDuration(const std::string& music_file_name);
    static void SetPlaybackTime(float time, std::size_t index = 0);

private:
    AudioEngine();
    ~AudioEngine();

    void EnginePollingThread();

    class Sfx;
    class SfxBuffers;
    class MusicPlayer {
    public:
        MusicPlayer();
        ~MusicPlayer();

        int SetMusic(Shared<Audio> music);
        int UpdatePlayer();

        /* These are the buffers and source to play out through OpenAL with. */
        ALuint m_Buffers[4];
        ALuint m_SourceID;

        Shared<Audio> m_Music;
        std::string m_MusicFileName;
        std::ifstream m_MusicFile;
        std::size_t m_Cursor;

        bool m_Playing;

    private:
        static constexpr int NumBuffers = 4;
    };

private:
    inline static AudioEngine* s_Instance;

    inline static ALCdevice* m_AlcDevice;
    inline static ALCcontext* m_AlcContext;

    inline static std::atomic_bool m_ShouldThreadClose;
    inline static std::thread m_PollingThread;

    inline static std::unordered_map<std::string, Sfx> m_SfxMap;
    inline static std::unordered_map<std::string, Audio*> m_MusicMap;

    inline static std::vector<SfxBuffers> m_SfxMixer;
    inline static std::mutex m_SfxMixerLock;

    inline static std::array<MusicPlayer, 4> m_MusicMixer;
    inline static std::mutex m_MusicMixerLock;

    static constexpr std::size_t MUSIC_BUFFER_SIZE = 65536;
};

// TODO: Merge Music and sfx to and turn them in to Audio(or sound or AudioClip(liek in unity));

class AudioEngine::Sfx {
public:
    Sfx(const std::string& sfxFileName);
    Sfx();

    int sampleRate;
    ALenum format;
    float duration;

    short* membuf;
    ALsizei num_bytes;
    sf_count_t num_frames;
};

class AudioEngine::SfxBuffers {
public:
    SfxBuffers(ALuint _sourceID, ALuint _bufferID);

    ALuint GetSourceID() const;
    const ALuint* GetSourceIDAddr() const;
    const ALuint* GetBufferIDAddr() const;

private:
    ALuint sourceID;
    ALuint bufferID;
};

} // namespace Tabby
