#include <Tabby/Audio/Audio.h>

#include <AL/al.h>
#include <AL/alext.h>

namespace Tabby {

struct VIOData {
    uint8_t* data;
    size_t size;
    size_t offset;
};

sf_count_t vfget_filelen(void* user_data)
{
    VIOData* vf = (VIOData*)user_data;
    std::cout << " -------------  offset = " << vf->offset << ", size = " << vf->size << std::endl;

    return vf->size;
}

sf_count_t vfseek(sf_count_t offset, int whence, void* user_data)
{
    VIOData* vf = (VIOData*)user_data;

    switch (whence) {
    case SEEK_SET:
        vf->offset = offset;
        break;

    case SEEK_CUR:
        vf->offset = vf->offset + offset;
        break;

    case SEEK_END:
        vf->offset = vf->size + offset;
        break;
    default:
        break;
    };

    std::cout << " -------------  offset = " << vf->offset << ", size = " << vf->size << std::endl;
    return vf->offset;
}

sf_count_t vfread(void* ptr, sf_count_t count, void* user_data)
{
    VIOData* vf = (VIOData*)user_data;

    std::cout << "1. Before read: offset = " << vf->offset << ", size = " << vf->size << std::endl;

    if (vf->offset >= vf->size) {
        std::cerr << "Error: offset exceeds buffer size" << std::endl;
        return 0;
    }

    if (vf->offset + count > vf->size) {
        count = vf->size - vf->offset;
    }

    std::cout << "2. After adjustment: count = " << count << ", offset = " << vf->offset << std::endl;

    if (count > 0 && count <= vf->size - vf->offset) {
        memcpy(ptr, vf->data + vf->offset, count);
        vf->offset += count;
    } else {
        std::cerr << "Error: invalid read operation. count=" << count << ", offset=" << vf->offset << std::endl;
        return 0;
    }

    std::cout << "3. After memcpy: count = " << count << ", offset = " << vf->offset << std::endl;

    return count;

    // VIOData* vf = (VIOData*)user_data;
    //
    // /*
    // **	This will break badly for files over 2Gig in length, but
    // **	is sufficient for testing.
    // */
    // // Tabby: yeah... testing
    // if (vf->offset + count > vf->buffer->Size)
    //     count = vf->buffer->Size - vf->offset;
    //
    // memcpy(ptr, vf->buffer->Data + vf->offset, count);
    // vf->offset += count;
    //
    // return count;
}

static sf_count_t vfwrite(const void* ptr, sf_count_t count, void* user_data)
{
    VIOData* vf = (VIOData*)user_data;

    /*
    **	This will break badly for files over 2Gig in length, but
    **	is sufficient for testing.
    */
    if (vf->offset >= (int)sizeof(vf->data))
        return 0;

    if (vf->offset + count > (int)sizeof(vf->data))
        count = sizeof(vf->data) - vf->offset;

    memcpy(vf->data + vf->offset, ptr, (size_t)count);
    vf->offset += count;

    if (vf->offset > vf->size)
        vf->size = vf->offset;

    std::cout << " -------------  offset = " << vf->offset << ", size = " << vf->size << std::endl;
    return count;
}

static sf_count_t vftell(void* user_data)
{
    VIOData* vf = (VIOData*)user_data;

    std::cout << " -------------  offset = " << vf->offset << ", size = " << vf->size << std::endl;
    return vf->offset;
}

Audio::Audio(const std::string& musicFileName, AssetHandle handle, Buffer data)
{
    Handle = handle;
    Type = AssetType::TABBY_AUDIO;

    // Set up the SF_VIRTUAL_IO structure
    SF_VIRTUAL_IO vio;
    vio.get_filelen = vfget_filelen;
    vio.seek = vfseek;
    vio.read = vfread;
    vio.write = vfwrite;
    vio.tell = vftell;

    int splblockalign = 0;

    VIOData vioData;
    vioData.data = new uint8_t[data.Size];
    memcpy(vioData.data, data.Data, data.Size);
    vioData.size = data.Size;
    vioData.offset = 0;

    // Load data from memory
    sndFile = sf_open_virtual(&vio, SFM_READ, &sfinfo, &vioData);

    // /* Open the audio file and check that it's usable. */
    // sndFile = sf_open(musicFileName.c_str(), SFM_READ, &sfinfo);

    if (!sndFile) {
        TB_CORE_ERROR("Could not open audio in {}: {}", musicFileName, sf_strerror(NULL));
        return;
    }

    /* Detect a suitable format to load. Formats like Vorbis and Opus use float
     * natively, so load as float to avoid clipping when possible. Formats
     * larger than 16-bit can also use float to preserve a bit more precision.
     */
    switch ((sfinfo.format & SF_FORMAT_SUBMASK)) {
    case SF_FORMAT_PCM_24:
    case SF_FORMAT_PCM_32:
    case SF_FORMAT_FLOAT:
    case SF_FORMAT_DOUBLE:
    case SF_FORMAT_VORBIS:
    case SF_FORMAT_OPUS:
    case SF_FORMAT_ALAC_20:
    case SF_FORMAT_ALAC_24:
    case SF_FORMAT_ALAC_32:
    case 0x0080 /*SF_FORMAT_MPEG_LAYER_I*/:
    case 0x0081 /*SF_FORMAT_MPEG_LAYER_II*/:
    case 0x0082 /*SF_FORMAT_MPEG_LAYER_III*/:
        if (alIsExtensionPresent("AL_EXT_FLOAT32"))
            sampleType = Float;
        break;
    case SF_FORMAT_IMA_ADPCM:
        /* ADPCM formats require setting a block alignment as specified in the
         * file, which needs to be read from the wave 'fmt ' chunk manually
         * since libsndfile doesn't provide it in a format-agnostic way.
         */
        if (sfinfo.channels <= 2
            && (sfinfo.format & SF_FORMAT_TYPEMASK) == SF_FORMAT_WAV
            && alIsExtensionPresent("AL_EXT_IMA4")
            && alIsExtensionPresent("AL_SOFT_block_alignment"))
            sampleType = IMA4;
        break;
    case SF_FORMAT_MS_ADPCM:
        if (sfinfo.channels <= 2
            && (sfinfo.format & SF_FORMAT_TYPEMASK) == SF_FORMAT_WAV
            && alIsExtensionPresent("AL_SOFT_MSADPCM")
            && alIsExtensionPresent("AL_SOFT_block_alignment"))
            sampleType = MSADPCM;
        break;
    }

    if (sampleType == IMA4 || sampleType == MSADPCM) {
        /* For ADPCM, lookup the wave file's "fmt " chunk, which is a
         * WAVEFORMATEX-based structure for the audio format.
         */
        SF_CHUNK_INFO inf = { "fmt ", 4, 0, NULL };
        SF_CHUNK_ITERATOR* iter = sf_get_chunk_iterator(sndFile, &inf);

        /* If there's an issue getting the chunk or block alignment, load as
         * 16-bit and have libsndfile do the conversion.
         */
        if (!iter || sf_get_chunk_size(iter, &inf) != SF_ERR_NO_ERROR || inf.datalen < 14)
            sampleType = Int16;
        else {
            ALubyte* fmtbuf = (ALubyte*)calloc(inf.datalen, 1);
            inf.data = fmtbuf;
            if (sf_get_chunk_data(iter, &inf) != SF_ERR_NO_ERROR)
                sampleType = Int16;
            else {
                /* Read the nBlockAlign field, and convert from bytes- to
                 * samples-per-block (verifying it's valid by converting back
                 * and comparing to the original value).
                 */
                byteblockalign = fmtbuf[12] | (fmtbuf[13] << 8);
                if (sampleType == IMA4) {
                    splblockalign = (byteblockalign / sfinfo.channels - 4) / 4 * 8 + 1;
                    if (splblockalign < 1
                        || ((splblockalign - 1) / 2 + 4) * sfinfo.channels != byteblockalign)
                        sampleType = Int16;
                } else {
                    splblockalign = (byteblockalign / sfinfo.channels - 7) * 2 + 2;
                    if (splblockalign < 2
                        || ((splblockalign - 2) / 2 + 7) * sfinfo.channels != byteblockalign)
                        sampleType = Int16;
                }
            }
            free(fmtbuf);
        }
    }

    if (sampleType == Int16) {
        sampleblockalign = 1;
        byteblockalign = sfinfo.channels * 2;
    } else if (sampleType == Float) {
        sampleblockalign = 1;
        byteblockalign = sfinfo.channels * 4;
    } else {
        sampleblockalign = splblockalign;
        byteblockalign = byteblockalign;
    }

    /* Figure out the OpenAL format from the file and desired sample type. */
    format = AL_NONE;
    if (sfinfo.channels == 1) {
        if (sampleType == Int16)
            format = AL_FORMAT_MONO16;
        else if (sampleType == Float)
            format = AL_FORMAT_MONO_FLOAT32;
        else if (sampleType == IMA4)
            format = AL_FORMAT_MONO_IMA4;
        else if (sampleType == MSADPCM)
            format = AL_FORMAT_MONO_MSADPCM_SOFT;
    } else if (sfinfo.channels == 2) {
        if (sampleType == Int16)
            format = AL_FORMAT_STEREO16;
        else if (sampleType == Float)
            format = AL_FORMAT_STEREO_FLOAT32;
        else if (sampleType == IMA4)
            format = AL_FORMAT_STEREO_IMA4;
        else if (sampleType == MSADPCM)
            format = AL_FORMAT_STEREO_MSADPCM_SOFT;
    } else if (sfinfo.channels == 3) {
        if (sf_command(sndFile, SFC_WAVEX_GET_AMBISONIC, NULL, 0) == SF_AMBISONIC_B_FORMAT) {
            if (sampleType == Int16)
                format = AL_FORMAT_BFORMAT2D_16;
            else if (sampleType == Float)
                format = AL_FORMAT_BFORMAT2D_FLOAT32;
        }
    } else if (sfinfo.channels == 4) {
        if (sf_command(sndFile, SFC_WAVEX_GET_AMBISONIC, NULL, 0) == SF_AMBISONIC_B_FORMAT) {
            if (sampleType == Int16)
                format = AL_FORMAT_BFORMAT3D_16;
            else if (sampleType == Float)
                format = AL_FORMAT_BFORMAT3D_FLOAT32;
        }
    }
    if (!format) {
        fprintf(stderr, "Unsupported channel count: %d\n", sfinfo.channels);
        sf_close(sndFile);
        sndFile = NULL;
        return;
    }

    blockCount = sfinfo.samplerate / sampleblockalign;
    blockCount = blockCount * BufferMillisec / 1000;
    membuf = malloc((size_t)blockCount * (size_t)byteblockalign);

    return;
}

Audio::~Audio()
{
    if (sndFile)
        sf_close(sndFile);
    sndFile = NULL;

    free(membuf);
    membuf = NULL;

    if (sampleblockalign > 1) {
        ALsizei i;
        sampleblockalign = 0;
        byteblockalign = 0;
    }
}

}
